{
  "version": 3,
  "sources": ["../../lib/cdp.ts", "../../lib/retry.ts", "../../lib/platforms/tymber.ts", "../../lib/platforms/leafbridge.ts", "../../cron/index.ts"],
  "sourceRoot": ".wrangler/build",
  "sourcesContent": ["/**\n * Lightweight CDP (Chrome DevTools Protocol) Client for Cloudflare Workers\n * \n * This is a minimal CDP implementation that works in Workers (no Node.js dependencies).\n * It connects to BrowserBase (or any CDP-compatible service) via WebSocket and\n * provides basic page automation: navigation, evaluation, screenshots.\n * \n * CDP Protocol Reference: https://chromedevtools.github.io/devtools-protocol/\n */\n\nexport interface CDPClientOptions {\n  /** WebSocket URL for CDP connection */\n  wsUrl: string;\n  /** Connection timeout in ms (default: 30000) */\n  timeout?: number;\n  /** Debug logging */\n  debug?: boolean;\n}\n\nexport interface CDPCommand {\n  method: string;\n  params?: Record<string, unknown>;\n  sessionId?: string;\n}\n\nexport interface CDPResponse<T = unknown> {\n  id: number;\n  result?: T;\n  error?: { code: number; message: string; data?: string };\n}\n\nexport interface TargetInfo {\n  targetId: string;\n  type: string;\n  title: string;\n  url: string;\n  attached: boolean;\n  browserContextId?: string;\n}\n\nexport interface PageNavigateResult {\n  frameId: string;\n  loaderId?: string;\n  errorText?: string;\n}\n\nexport interface RuntimeEvaluateResult {\n  result: {\n    type: string;\n    value?: unknown;\n    description?: string;\n    objectId?: string;\n  };\n  exceptionDetails?: {\n    text: string;\n    exception?: { description: string };\n  };\n}\n\n/**\n * Minimal CDP client for Cloudflare Workers\n * \n * Usage:\n * ```ts\n * const client = new CDPClient({ wsUrl: 'wss://connect.browserbase.com?apiKey=...' });\n * await client.connect();\n * \n * const page = await client.createPage();\n * await page.navigate('https://example.com');\n * const result = await page.evaluate('document.title');\n * await page.close();\n * \n * await client.disconnect();\n * ```\n */\nexport class CDPClient {\n  private ws: WebSocket | null = null;\n  private messageId = 0;\n  private pending = new Map<number, {\n    resolve: (value: unknown) => void;\n    reject: (error: Error) => void;\n  }>();\n  private options: Required<CDPClientOptions>;\n  private connected = false;\n  private eventListeners = new Map<string, Set<(params: unknown) => void>>();\n\n  constructor(options: CDPClientOptions) {\n    this.options = {\n      wsUrl: options.wsUrl,\n      timeout: options.timeout ?? 30000,\n      debug: options.debug ?? false,\n    };\n  }\n\n  private log(...args: unknown[]) {\n    if (this.options.debug) {\n      console.log('[CDP]', ...args);\n    }\n  }\n\n  /**\n   * Connect to the CDP WebSocket endpoint\n   */\n  async connect(): Promise<void> {\n    if (this.connected) return;\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(`CDP connection timeout after ${this.options.timeout}ms`));\n      }, this.options.timeout);\n\n      this.log('Connecting to', this.options.wsUrl.replace(/apiKey=[^&]+/, 'apiKey=***'));\n\n      // Use Cloudflare Workers WebSocket (via fetch upgrade)\n      // For standard WebSocket environments:\n      this.ws = new WebSocket(this.options.wsUrl);\n\n      this.ws.addEventListener('open', () => {\n        clearTimeout(timeout);\n        this.connected = true;\n        this.log('Connected');\n        resolve();\n      });\n\n      this.ws.addEventListener('error', (event) => {\n        clearTimeout(timeout);\n        const error = new Error('CDP WebSocket error');\n        this.log('WebSocket error:', event);\n        reject(error);\n      });\n\n      this.ws.addEventListener('close', (event) => {\n        this.connected = false;\n        this.log('WebSocket closed:', event.code, event.reason);\n        // Reject all pending requests\n        for (const [id, { reject }] of this.pending) {\n          reject(new Error(`WebSocket closed (${event.code}): ${event.reason}`));\n          this.pending.delete(id);\n        }\n      });\n\n      this.ws.addEventListener('message', (event) => {\n        this.handleMessage(event.data);\n      });\n    });\n  }\n\n  private handleMessage(data: string | ArrayBuffer) {\n    try {\n      const message = JSON.parse(typeof data === 'string' ? data : new TextDecoder().decode(data));\n      \n      // Handle response to a command\n      if ('id' in message) {\n        const pending = this.pending.get(message.id);\n        if (pending) {\n          this.pending.delete(message.id);\n          if (message.error) {\n            pending.reject(new Error(`CDP Error ${message.error.code}: ${message.error.message}`));\n          } else {\n            pending.resolve(message.result);\n          }\n        }\n      }\n      \n      // Handle events\n      if ('method' in message && !('id' in message)) {\n        this.log('Event:', message.method);\n        const listeners = this.eventListeners.get(message.method);\n        if (listeners) {\n          for (const listener of listeners) {\n            try {\n              listener(message.params);\n            } catch (e) {\n              this.log('Event listener error:', e);\n            }\n          }\n        }\n      }\n    } catch (e) {\n      this.log('Failed to parse message:', e);\n    }\n  }\n\n  /**\n   * Send a CDP command and wait for response\n   */\n  async send<T = unknown>(command: CDPCommand): Promise<T> {\n    if (!this.ws || !this.connected) {\n      throw new Error('CDP not connected');\n    }\n\n    const id = ++this.messageId;\n    const message = {\n      id,\n      method: command.method,\n      params: command.params ?? {},\n      ...(command.sessionId ? { sessionId: command.sessionId } : {}),\n    };\n\n    this.log('Send:', command.method, command.params);\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.pending.delete(id);\n        reject(new Error(`CDP command timeout: ${command.method}`));\n      }, this.options.timeout);\n\n      this.pending.set(id, {\n        resolve: (value) => {\n          clearTimeout(timeout);\n          resolve(value as T);\n        },\n        reject: (error) => {\n          clearTimeout(timeout);\n          reject(error);\n        },\n      });\n\n      this.ws!.send(JSON.stringify(message));\n    });\n  }\n\n  /**\n   * Subscribe to CDP events\n   */\n  on(event: string, callback: (params: unknown) => void): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, new Set());\n    }\n    this.eventListeners.get(event)!.add(callback);\n  }\n\n  /**\n   * Unsubscribe from CDP events\n   */\n  off(event: string, callback: (params: unknown) => void): void {\n    this.eventListeners.get(event)?.delete(callback);\n  }\n\n  /**\n   * Get list of available targets (pages/tabs)\n   */\n  async getTargets(): Promise<{ targetInfos: TargetInfo[] }> {\n    return this.send({ method: 'Target.getTargets' });\n  }\n\n  /**\n   * Create a new page/tab and return a CDPPage instance\n   */\n  async createPage(url = 'about:blank'): Promise<CDPPage> {\n    // Create a new target (page)\n    const { targetId } = await this.send<{ targetId: string }>({\n      method: 'Target.createTarget',\n      params: { url },\n    });\n\n    this.log('Created target:', targetId);\n\n    // Attach to the target to get a session\n    const { sessionId } = await this.send<{ sessionId: string }>({\n      method: 'Target.attachToTarget',\n      params: { targetId, flatten: true },\n    });\n\n    this.log('Attached to target, sessionId:', sessionId);\n\n    // Enable necessary domains\n    await this.send({ method: 'Page.enable', sessionId });\n    await this.send({ method: 'Runtime.enable', sessionId });\n\n    return new CDPPage(this, targetId, sessionId);\n  }\n\n  /**\n   * Attach to an existing page target\n   */\n  async attachToPage(targetId: string): Promise<CDPPage> {\n    const { sessionId } = await this.send<{ sessionId: string }>({\n      method: 'Target.attachToTarget',\n      params: { targetId, flatten: true },\n    });\n\n    await this.send({ method: 'Page.enable', sessionId });\n    await this.send({ method: 'Runtime.enable', sessionId });\n\n    return new CDPPage(this, targetId, sessionId);\n  }\n\n  /**\n   * Get the first page target (usually the default tab)\n   */\n  async getFirstPage(): Promise<CDPPage | null> {\n    const { targetInfos } = await this.getTargets();\n    const pageTarget = targetInfos.find(t => t.type === 'page');\n    if (!pageTarget) return null;\n    return this.attachToPage(pageTarget.targetId);\n  }\n\n  /**\n   * Disconnect from CDP\n   */\n  async disconnect(): Promise<void> {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n      this.connected = false;\n    }\n  }\n\n  get isConnected(): boolean {\n    return this.connected;\n  }\n}\n\n/**\n * Represents a browser page/tab connected via CDP\n */\nexport class CDPPage {\n  constructor(\n    private client: CDPClient,\n    private targetId: string,\n    private sessionId: string\n  ) {}\n\n  /**\n   * Navigate to a URL\n   */\n  async navigate(url: string, options?: { \n    waitUntil?: 'load' | 'domcontentloaded';\n    timeout?: number;\n  }): Promise<PageNavigateResult> {\n    const result = await this.client.send<PageNavigateResult>({\n      method: 'Page.navigate',\n      params: { url },\n      sessionId: this.sessionId,\n    });\n\n    if (result.errorText) {\n      throw new Error(`Navigation failed: ${result.errorText}`);\n    }\n\n    // Wait for load event if requested\n    if (options?.waitUntil === 'load') {\n      await this.waitForLoadEvent(options.timeout);\n    }\n\n    return result;\n  }\n\n  /**\n   * Wait for page load event\n   */\n  private async waitForLoadEvent(timeout = 30000): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        this.client.off('Page.loadEventFired', handler);\n        reject(new Error('Timeout waiting for page load'));\n      }, timeout);\n\n      const handler = () => {\n        clearTimeout(timeoutId);\n        this.client.off('Page.loadEventFired', handler);\n        resolve();\n      };\n\n      this.client.on('Page.loadEventFired', handler);\n    });\n  }\n\n  /**\n   * Wait for a specified time (simple delay)\n   */\n  async waitForTimeout(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Evaluate JavaScript in the page context\n   */\n  async evaluate<T = unknown>(expression: string): Promise<T> {\n    const result = await this.client.send<RuntimeEvaluateResult>({\n      method: 'Runtime.evaluate',\n      params: {\n        expression,\n        returnByValue: true,\n        awaitPromise: true,\n      },\n      sessionId: this.sessionId,\n    });\n\n    if (result.exceptionDetails) {\n      const errorMsg = result.exceptionDetails.exception?.description || \n                       result.exceptionDetails.text;\n      throw new Error(`Evaluation failed: ${errorMsg}`);\n    }\n\n    return result.result.value as T;\n  }\n\n  /**\n   * Evaluate a function with serialized arguments\n   */\n  async evaluateFunction<T = unknown>(\n    fn: (...args: unknown[]) => T,\n    ...args: unknown[]\n  ): Promise<T> {\n    // Serialize the function and call it with args\n    const serializedArgs = JSON.stringify(args);\n    const expression = `(${fn.toString()}).apply(null, ${serializedArgs})`;\n    return this.evaluate<T>(expression);\n  }\n\n  /**\n   * Get page content (HTML)\n   */\n  async content(): Promise<string> {\n    return this.evaluate<string>('document.documentElement.outerHTML');\n  }\n\n  /**\n   * Get page title\n   */\n  async title(): Promise<string> {\n    return this.evaluate<string>('document.title');\n  }\n\n  /**\n   * Get current URL\n   */\n  async url(): Promise<string> {\n    return this.evaluate<string>('window.location.href');\n  }\n\n  /**\n   * Take a screenshot\n   */\n  async screenshot(options?: {\n    format?: 'png' | 'jpeg' | 'webp';\n    quality?: number;\n    fullPage?: boolean;\n  }): Promise<string> {\n    const params: Record<string, unknown> = {\n      format: options?.format ?? 'png',\n    };\n\n    if (options?.quality !== undefined) {\n      params.quality = options.quality;\n    }\n\n    if (options?.fullPage) {\n      // Get full page dimensions\n      const metrics = await this.client.send<{\n        cssContentSize: { width: number; height: number };\n      }>({\n        method: 'Page.getLayoutMetrics',\n        sessionId: this.sessionId,\n      });\n\n      params.clip = {\n        x: 0,\n        y: 0,\n        width: metrics.cssContentSize.width,\n        height: metrics.cssContentSize.height,\n        scale: 1,\n      };\n      params.captureBeyondViewport = true;\n    }\n\n    const result = await this.client.send<{ data: string }>({\n      method: 'Page.captureScreenshot',\n      params,\n      sessionId: this.sessionId,\n    });\n\n    return result.data; // Base64-encoded image\n  }\n\n  /**\n   * Set viewport size\n   */\n  async setViewport(width: number, height: number): Promise<void> {\n    await this.client.send({\n      method: 'Emulation.setDeviceMetricsOverride',\n      params: {\n        width,\n        height,\n        deviceScaleFactor: 1,\n        mobile: false,\n      },\n      sessionId: this.sessionId,\n    });\n  }\n\n  /**\n   * Click an element by selector\n   */\n  async click(selector: string): Promise<void> {\n    // Use Runtime.evaluate to click the element\n    await this.evaluate(`\n      const el = document.querySelector(${JSON.stringify(selector)});\n      if (!el) throw new Error('Element not found: ${selector}');\n      el.click();\n    `);\n  }\n\n  /**\n   * Type text into an input\n   */\n  async type(selector: string, text: string): Promise<void> {\n    await this.evaluate(`\n      const el = document.querySelector(${JSON.stringify(selector)});\n      if (!el) throw new Error('Element not found: ${selector}');\n      el.focus();\n      el.value = ${JSON.stringify(text)};\n      el.dispatchEvent(new Event('input', { bubbles: true }));\n      el.dispatchEvent(new Event('change', { bubbles: true }));\n    `);\n  }\n\n  /**\n   * Wait for a selector to appear\n   */\n  async waitForSelector(\n    selector: string, \n    options?: { timeout?: number; visible?: boolean }\n  ): Promise<void> {\n    const timeout = options?.timeout ?? 30000;\n    const startTime = Date.now();\n    const checkVisible = options?.visible ?? false;\n\n    while (Date.now() - startTime < timeout) {\n      const found = await this.evaluate<boolean>(`\n        (() => {\n          const el = document.querySelector(${JSON.stringify(selector)});\n          if (!el) return false;\n          if (${checkVisible}) {\n            const style = window.getComputedStyle(el);\n            return style.display !== 'none' && style.visibility !== 'hidden';\n          }\n          return true;\n        })()\n      `);\n\n      if (found) return;\n      await this.waitForTimeout(100);\n    }\n\n    throw new Error(`Timeout waiting for selector: ${selector}`);\n  }\n\n  /**\n   * Close the page\n   */\n  async close(): Promise<void> {\n    await this.client.send({\n      method: 'Target.closeTarget',\n      params: { targetId: this.targetId },\n    });\n  }\n\n  /**\n   * Get the target ID\n   */\n  getTargetId(): string {\n    return this.targetId;\n  }\n\n  /**\n   * Get the session ID\n   */\n  getSessionId(): string {\n    return this.sessionId;\n  }\n}\n\n/**\n * BrowserBase session creation options\n */\nexport interface BrowserBaseSessionOptions {\n  /** Enable residential proxies for bot detection bypass */\n  proxies?: boolean;\n  /** Proxy geolocation (e.g., 'US', 'US-NY') */\n  proxyGeolocation?: string;\n  /** Browser fingerprint ID for consistent fingerprinting */\n  fingerprintId?: string;\n  /** Enable stealth mode (recommended with proxies) */\n  stealth?: boolean;\n}\n\n/**\n * Create a BrowserBase session and get CDP connection URL\n * BrowserBase requires: 1) Create session via REST, 2) Connect to returned connectUrl\n * \n * @param apiKey - BrowserBase API key\n * @param projectId - BrowserBase project ID\n * @param options - Session options (proxies, geolocation, stealth, etc.)\n */\nasync function createBrowserBaseSession(\n  apiKey: string,\n  projectId: string,\n  options?: BrowserBaseSessionOptions\n): Promise<string> {\n  const body: Record<string, unknown> = { projectId };\n  \n  // Enable residential proxies if requested\n  if (options?.proxies) {\n    body.proxies = true;\n    console.log('[CDP] Residential proxies ENABLED');\n  }\n  \n  // Set proxy geolocation if specified (e.g., 'US-NY' for New York)\n  if (options?.proxyGeolocation) {\n    body.browserSettings = {\n      ...(body.browserSettings as Record<string, unknown> || {}),\n      proxy: {\n        geolocation: options.proxyGeolocation\n      }\n    };\n    console.log(`[CDP] Proxy geolocation: ${options.proxyGeolocation}`);\n  }\n  \n  // Enable stealth mode (helps with bot detection)\n  if (options?.stealth !== false && options?.proxies) {\n    // Stealth is auto-enabled with proxies by default\n    console.log('[CDP] Stealth mode: auto-enabled with proxies');\n  }\n  \n  // Use consistent fingerprint if specified\n  if (options?.fingerprintId) {\n    body.fingerprint = { id: options.fingerprintId };\n    console.log(`[CDP] Using fingerprint: ${options.fingerprintId}`);\n  }\n\n  const response = await fetch('https://www.browserbase.com/v1/sessions', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'x-bb-api-key': apiKey,\n    },\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    const text = await response.text();\n    throw new Error(`BrowserBase session creation failed: ${response.status} ${text}`);\n  }\n\n  const session = await response.json() as { connectUrl: string; id: string };\n  if (!session.connectUrl) {\n    throw new Error('BrowserBase session missing connectUrl');\n  }\n\n  console.log(`[CDP] BrowserBase session created: ${session.id}${options?.proxies ? ' (with residential proxy)' : ''}`);\n  return session.connectUrl;\n}\n\n/**\n * Create a BrowserBase CDP client (legacy - use BrowserSession instead)\n */\nexport function createBrowserBaseClient(\n  apiKey: string,\n  projectId: string,\n  options?: Omit<CDPClientOptions, 'wsUrl'>\n): CDPClient {\n  // This is now just a placeholder - actual connection happens in BrowserSession.init()\n  const wsUrl = `wss://placeholder.browserbase.com`;\n  return new CDPClient({ wsUrl, ...options });\n}\n\n/**\n * BrowserSession options\n */\nexport interface BrowserSessionOptions {\n  /** Enable debug logging */\n  debug?: boolean;\n  /** Enable residential proxies (bypasses datacenter IP blocking) */\n  proxies?: boolean;\n  /** Proxy geolocation (e.g., 'US', 'US-NY') */\n  proxyGeolocation?: string;\n  /** Fingerprint ID for consistent browser fingerprinting */\n  fingerprintId?: string;\n}\n\n/**\n * Higher-level browser abstraction for simple scraping tasks\n */\nexport class BrowserSession {\n  private client: CDPClient | null = null;\n  private page: CDPPage | null = null;\n  private apiKey: string;\n  private projectId: string;\n  private options: BrowserSessionOptions;\n\n  constructor(apiKey: string, projectId: string, options: BrowserSessionOptions | boolean = false) {\n    this.apiKey = apiKey;\n    this.projectId = projectId;\n    // Support legacy boolean (debug) or new options object\n    this.options = typeof options === 'boolean' ? { debug: options } : options;\n  }\n\n  async init(): Promise<void> {\n    // Step 1: Create BrowserBase session and get connectUrl\n    const connectUrl = await createBrowserBaseSession(this.apiKey, this.projectId, {\n      proxies: this.options.proxies,\n      proxyGeolocation: this.options.proxyGeolocation,\n      fingerprintId: this.options.fingerprintId,\n    });\n    \n    // Step 2: Create CDP client with the actual connectUrl\n    this.client = new CDPClient({ wsUrl: connectUrl, debug: this.options.debug ?? false });\n    \n    // Step 3: Connect via WebSocket\n    await this.client.connect();\n    \n    // Step 4: Get the default page or create one\n    this.page = await this.client.getFirstPage() || await this.client.createPage();\n    await this.page.setViewport(1280, 800);\n  }\n\n  async goto(url: string): Promise<void> {\n    if (!this.page || !this.client) throw new Error('Session not initialized');\n    await this.page.navigate(url);\n  }\n\n  async waitForTimeout(ms: number): Promise<void> {\n    if (!this.page || !this.client) throw new Error('Session not initialized');\n    await this.page.waitForTimeout(ms);\n  }\n\n  async evaluate<T = unknown>(expression: string): Promise<T> {\n    if (!this.page || !this.client) throw new Error('Session not initialized');\n    return this.page.evaluate<T>(expression);\n  }\n\n  async evaluateFunction<T = unknown>(\n    fn: (...args: unknown[]) => T,\n    ...args: unknown[]\n  ): Promise<T> {\n    if (!this.page || !this.client) throw new Error('Session not initialized');\n    return this.page.evaluateFunction(fn, ...args);\n  }\n\n  async screenshot(options?: Parameters<CDPPage['screenshot']>[0]): Promise<string> {\n    if (!this.page || !this.client) throw new Error('Session not initialized');\n    return this.page.screenshot(options);\n  }\n\n  async close(): Promise<void> {\n    if (this.page) {\n      try {\n        await this.page.close();\n      } catch (e) {\n        // Ignore close errors\n      }\n    }\n    if (this.client) {\n      await this.client.disconnect();\n    }\n  }\n\n  getPage(): CDPPage | null {\n    return this.page;\n  }\n\n  /**\n   * Get the underlying CDP client for advanced operations (e.g., creating multiple pages)\n   */\n  getClient(): CDPClient | null {\n    return this.client;\n  }\n\n  /**\n   * Create additional pages for parallel operations\n   */\n  async createPage(url = 'about:blank'): Promise<CDPPage> {\n    if (!this.client) throw new Error('Session not initialized');\n    const page = await this.client.createPage(url);\n    await page.setViewport(1280, 800);\n    return page;\n  }\n}\n", "/**\n * Retry Utilities for Workers (CRIT-001, CRIT-002)\n * \n * Provides exponential backoff and circuit breaker patterns\n * for resilient HTTP and browser operations.\n */\n\nexport interface RetryOptions {\n  maxRetries: number;\n  baseDelayMs: number;\n  maxDelayMs: number;\n  backoffMultiplier: number;\n  retryableErrors?: string[];\n  onRetry?: (attempt: number, error: Error, delayMs: number) => void;\n}\n\nconst DEFAULT_OPTIONS: RetryOptions = {\n  maxRetries: 3,\n  baseDelayMs: 1000,\n  maxDelayMs: 30000,\n  backoffMultiplier: 2,\n  retryableErrors: ['ETIMEDOUT', 'ECONNRESET', 'ECONNREFUSED', 'fetch failed', 'timeout'],\n};\n\nfunction calculateDelay(attempt: number, options: RetryOptions): number {\n  const exponentialDelay = options.baseDelayMs * Math.pow(options.backoffMultiplier, attempt - 1);\n  const jitter = Math.random() * 0.3 * exponentialDelay;\n  return Math.min(exponentialDelay + jitter, options.maxDelayMs);\n}\n\nfunction isRetryable(error: Error, options: RetryOptions): boolean {\n  const errorStr = error.message.toLowerCase();\n  if (errorStr.includes('429') || errorStr.includes('503') || errorStr.includes('502')) {\n    return true;\n  }\n  return options.retryableErrors?.some(pattern => \n    errorStr.includes(pattern.toLowerCase())\n  ) ?? false;\n}\n\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  options: Partial<RetryOptions> = {}\n): Promise<T> {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  let lastError: Error | null = null;\n  \n  for (let attempt = 1; attempt <= opts.maxRetries + 1; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n      const isLastAttempt = attempt > opts.maxRetries;\n      const canRetry = !isLastAttempt && isRetryable(lastError, opts);\n      if (!canRetry) throw lastError;\n      const delay = calculateDelay(attempt, opts);\n      opts.onRetry?.(attempt, lastError, delay);\n      await sleep(delay);\n    }\n  }\n  throw lastError;\n}\n\nexport async function fetchWithRetry(\n  url: string,\n  init?: RequestInit & { timeoutMs?: number },\n  options: Partial<RetryOptions> = {}\n): Promise<Response> {\n  const { timeoutMs = 30000, ...fetchInit } = init || {};\n  \n  return withRetry(async () => {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), timeoutMs);\n    try {\n      const response = await fetch(url, { ...fetchInit, signal: controller.signal });\n      if (response.status >= 500 || response.status === 429) {\n        const text = await response.text().catch(() => '');\n        throw new Error(`HTTP ${response.status}: ${text.slice(0, 200)}`);\n      }\n      return response;\n    } finally {\n      clearTimeout(timeout);\n    }\n  }, options);\n}\n\ninterface CircuitState {\n  failures: number;\n  lastFailure: number;\n  state: 'closed' | 'open' | 'half-open';\n}\n\nconst circuits = new Map<string, CircuitState>();\n\nexport function withCircuitBreaker<T>(\n  key: string,\n  fn: () => Promise<T>,\n  options: { failureThreshold: number; resetTimeMs: number; halfOpenRequests: number } = {\n    failureThreshold: 5,\n    resetTimeMs: 60000,\n    halfOpenRequests: 1,\n  }\n): Promise<T> {\n  let circuit = circuits.get(key);\n  if (!circuit) {\n    circuit = { failures: 0, lastFailure: 0, state: 'closed' };\n    circuits.set(key, circuit);\n  }\n  \n  const now = Date.now();\n  if (circuit.state === 'open' && now - circuit.lastFailure > options.resetTimeMs) {\n    circuit.state = 'half-open';\n    circuit.failures = 0;\n  }\n  \n  if (circuit.state === 'open') {\n    throw new Error(`Circuit breaker open for ${key}. Will retry after ${Math.round((options.resetTimeMs - (now - circuit.lastFailure)) / 1000)}s`);\n  }\n  \n  return fn()\n    .then(result => {\n      circuit!.failures = 0;\n      circuit!.state = 'closed';\n      return result;\n    })\n    .catch(error => {\n      circuit!.failures++;\n      circuit!.lastFailure = now;\n      if (circuit!.failures >= options.failureThreshold) {\n        circuit!.state = 'open';\n        console.error(`[CircuitBreaker] ${key} opened after ${circuit!.failures} failures`);\n      }\n      throw error;\n    });\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n", "/**\n * Tymber/Blaze Platform Scraper\n * \n * Extracts products with inventory from Tymber SSR pages (e.g., Housing Works Cannabis)\n * Products are embedded in __NEXT_DATA__ JSON - no browser automation needed.\n * \n * Key fields:\n * - pos_inventory: exact stock count\n * - in_stock: boolean availability\n * - unit_price.amount: price in cents\n */\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface TymberRawProduct {\n  attributes: {\n    id: number;\n    name: string;\n    slug: string;\n    store_url: string;\n    main_image?: string;\n    unit_price?: { amount: number; currency: string };\n    discount_price?: number | null;\n    on_sale?: boolean;\n    pos_inventory: number;  // CRITICAL: exact stock count\n    in_stock: boolean;\n    flower_type?: string;\n    thc?: { amount: string; units: string };\n    cbd?: { amount: string; units: string };\n    size?: { amount: number; type: string; units: string; display_text?: string };\n    description?: string;\n  };\n  relationships?: {\n    category?: { data?: { attributes?: { name: string; slug: string } } };\n    brand?: { data?: { attributes?: { name: string } } };\n    tags?: { data?: Array<{ attributes?: { name: string } }> };\n  };\n}\n\nexport interface TymberScrapedProduct {\n  rawProductName: string;\n  rawBrandName: string;\n  rawCategory?: string;\n  price: number;\n  originalPrice?: number;\n  inStock: boolean;\n  quantity: number | null;\n  quantityWarning: string | null;\n  quantitySource: string;\n  imageUrl?: string;\n  thcFormatted?: string;\n  cbdFormatted?: string;\n  sourceUrl: string;\n  sourcePlatform: string;\n  scrapedAt: number;\n  productUrl?: string;\n}\n\n// ============================================================================\n// PLATFORM DETECTION\n// ============================================================================\n\nconst TYMBER_URL_PATTERNS = [\n  /hwcannabis\\.co/i,\n  /\\.tymber\\.me/i,\n  /tymber\\.io/i,\n];\n\nconst TYMBER_HTML_SIGNATURES = [\n  'ecom-api.blaze.me',\n  'tymber-s3.imgix.net',\n  'tymber-blaze-products.imgix.net',\n  '\"siteGroupName\":\"tymber-',\n];\n\n/**\n * Detect if a URL/HTML belongs to a Tymber/Blaze platform site\n */\nexport function isTymberSite(url: string, html?: string): boolean {\n  // URL-based detection\n  for (const pattern of TYMBER_URL_PATTERNS) {\n    if (pattern.test(url)) return true;\n  }\n  \n  // HTML-based detection\n  if (html) {\n    for (const sig of TYMBER_HTML_SIGNATURES) {\n      if (html.includes(sig)) return true;\n    }\n  }\n  \n  return false;\n}\n\n// ============================================================================\n// SSR JSON EXTRACTION\n// ============================================================================\n\n/**\n * Extract raw product data from __NEXT_DATA__ JSON\n */\nexport function extractTymberSSRData(html: string): TymberRawProduct[] {\n  const products: TymberRawProduct[] = [];\n  \n  // Find __NEXT_DATA__ script tag\n  const match = html.match(/<script\\s+id=\"__NEXT_DATA__\"[^>]*>([^<]+)<\\/script>/);\n  if (!match) {\n    console.log('[Tymber] No __NEXT_DATA__ found in HTML');\n    return products;\n  }\n  \n  try {\n    const data = JSON.parse(match[1]);\n    const pageProps = data?.props?.pageProps;\n    \n    if (!pageProps) {\n      console.log('[Tymber] No pageProps in __NEXT_DATA__');\n      return products;\n    }\n    \n    // Extract from showcasedGroups (main product listings)\n    const showcasedGroups = pageProps?.showcasedGroups?.data || \n                            pageProps?.homeData?.showcasedGroups || \n                            [];\n    \n    for (const group of showcasedGroups) {\n      const groupProducts = group?.products?.data?.objects || [];\n      products.push(...groupProducts);\n    }\n    \n    // Extract from deals if present (can be array or object)\n    const deals = pageProps?.deals;\n    if (Array.isArray(deals)) {\n      for (const deal of deals) {\n        const dealProducts = deal?.products || [];\n        products.push(...dealProducts);\n      }\n    }\n    \n    // Extract from search results if present\n    const searchProducts = pageProps?.products?.data?.objects || [];\n    products.push(...searchProducts);\n    \n    console.log(`[Tymber] Extracted ${products.length} products from SSR data`);\n    \n  } catch (error) {\n    console.error('[Tymber] Failed to parse __NEXT_DATA__:', error);\n  }\n  \n  return products;\n}\n\n// ============================================================================\n// FIELD MAPPING\n// ============================================================================\n\n/**\n * Map Tymber product to our ScrapedProduct format\n */\nexport function mapTymberToScrapedProduct(\n  raw: TymberRawProduct, \n  sourceUrl: string\n): TymberScrapedProduct {\n  const attrs = raw.attributes || {};\n  const rels = raw.relationships || {};\n  \n  // Price is in cents, convert to dollars\n  const priceInCents = attrs.unit_price?.amount || 0;\n  const price = priceInCents / 100;\n  \n  // Get quantity - this is the key field!\n  const quantity = typeof attrs.pos_inventory === 'number' ? attrs.pos_inventory : null;\n  \n  // Determine if low stock\n  let quantityWarning: string | null = null;\n  if (quantity !== null && quantity > 0 && quantity <= 5) {\n    quantityWarning = `Only ${quantity} left`;\n  } else if (quantity === 0 || !attrs.in_stock) {\n    quantityWarning = 'Out of stock';\n  }\n  \n  return {\n    rawProductName: attrs.name || 'Unknown',\n    rawBrandName: rels.brand?.data?.attributes?.name || 'Unknown',\n    rawCategory: rels.category?.data?.attributes?.name,\n    price,\n    originalPrice: attrs.discount_price ? price : undefined,\n    inStock: attrs.in_stock ?? (quantity !== null && quantity > 0),\n    quantity,\n    quantityWarning,\n    quantitySource: 'tymber_ssr',\n    imageUrl: attrs.main_image,\n    thcFormatted: attrs.thc ? `${attrs.thc.amount}${attrs.thc.units}` : undefined,\n    cbdFormatted: attrs.cbd ? `${attrs.cbd.amount}${attrs.cbd.units}` : undefined,\n    sourceUrl,\n    sourcePlatform: 'tymber',\n    scrapedAt: Date.now(),\n    productUrl: attrs.store_url,\n  };\n}\n\n// ============================================================================\n// MAIN SCRAPE FUNCTION\n// ============================================================================\n\n/**\n * Scrape products from a Tymber/Blaze site\n * \n * @param html - Raw HTML from the page\n * @param sourceUrl - URL of the page being scraped\n * @returns Array of ScrapedProduct with inventory data\n */\nexport function scrapeTymberProducts(html: string, sourceUrl: string): TymberScrapedProduct[] {\n  const rawProducts = extractTymberSSRData(html);\n  return rawProducts.map(raw => mapTymberToScrapedProduct(raw, sourceUrl));\n}\n\n/**\n * Fetch and scrape a Tymber site (convenience function for Workers)\n */\nexport async function fetchAndScrapeTymber(url: string): Promise<TymberScrapedProduct[]> {\n  const response = await fetch(url, {\n    headers: {\n      'User-Agent': 'Mozilla/5.0 (compatible; CannaSignal/1.0)',\n      'Accept': 'text/html',\n    },\n  });\n  \n  if (!response.ok) {\n    throw new Error(`Failed to fetch ${url}: ${response.status}`);\n  }\n  \n  const html = await response.text();\n  return scrapeTymberProducts(html, url);\n}\n", "/**\n * LeafBridge Platform Detection and Scraping\n * \n * WordPress plugin used by some dispensaries (e.g., Alta Dispensary)\n * Products are rendered via AJAX with custom CSS classes.\n * \n * Unlike Tymber, LeafBridge requires browser-based extraction since\n * products are loaded via AJAX after initial page render.\n */\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface LeafBridgeScrapedProduct {\n  rawProductName: string;\n  rawBrandName: string;\n  rawCategory?: string;\n  price: number;\n  inStock: boolean;\n  quantity: number | null;\n  quantityWarning: string | null;\n  quantitySource: string;\n  sourceUrl: string;\n  sourcePlatform: string;\n  scrapedAt: number;\n}\n\n// ============================================================================\n// PLATFORM DETECTION\n// ============================================================================\n\nconst LEAFBRIDGE_URL_PATTERNS = [\n  /altadispensary\\.nyc/i,\n];\n\nconst LEAFBRIDGE_HTML_SIGNATURES = [\n  'leafbridge_product_card',\n  '/plugins/leafbridge/',\n  'leafbridge_public_ajax_obj',\n];\n\n/**\n * Detect if a URL/HTML belongs to a LeafBridge platform site\n */\nexport function isLeafBridgeSite(url: string, html?: string): boolean {\n  // URL-based detection\n  for (const pattern of LEAFBRIDGE_URL_PATTERNS) {\n    if (pattern.test(url)) return true;\n  }\n  \n  // HTML-based detection\n  if (html) {\n    for (const sig of LEAFBRIDGE_HTML_SIGNATURES) {\n      if (html.includes(sig)) return true;\n    }\n  }\n  \n  return false;\n}\n\n// ============================================================================\n// SELECTORS\n// ============================================================================\n\n/**\n * CSS selectors for LeafBridge product elements\n */\nexport const LEAFBRIDGE_SELECTORS = {\n  productCard: '.leafbridge_product_card',\n  productName: '.leafbridge_product_name',\n  brandName: '.leafbridge_brand_name',\n  price: '.leafbridge_product_price',\n  soldOut: '.add_to_cart_soldout',\n  quantityInput: 'input[type=\"number\"]',\n};\n\n/**\n * The primary selector to wait for before extracting products.\n * LeafBridge loads products via AJAX, so we need to wait for cards to appear.\n */\nexport const LEAFBRIDGE_WAIT_SELECTOR = '.leafbridge_product_card';\n\n/**\n * Time to wait for AJAX content to load (ms).\n * LeafBridge can be slow to load products; 5s is conservative.\n */\nexport const LEAFBRIDGE_AJAX_WAIT_MS = 5000;\n\n// ============================================================================\n// BROWSER-BASED EXTRACTION\n// ============================================================================\n\n/**\n * Extract products from the DOM after AJAX loads.\n * \n * IMPORTANT: This function runs in browser context via page.evaluate().\n * It cannot access Node.js APIs or external variables.\n * \n * Usage with BrowserSession:\n * ```typescript\n * await session.goto(url);\n * await session.waitForTimeout(LEAFBRIDGE_AJAX_WAIT_MS);\n * const products = await session.evaluateFunction(\n *   extractLeafBridgeProductsFromDOM,\n *   sourceUrl,\n *   Date.now()\n * );\n * ```\n * \n * @param sourceUrl - The URL being scraped (passed from caller)\n * @param timestamp - When scraping started (passed from caller)\n * @returns Array of scraped products from the current page\n */\nexport function extractLeafBridgeProductsFromDOM(\n  sourceUrl: string,\n  timestamp: number\n): LeafBridgeScrapedProduct[] {\n  const products: LeafBridgeScrapedProduct[] = [];\n  \n  // Primary selector\n  let cards = document.querySelectorAll('.leafbridge_product_card');\n  \n  // Fallback if primary doesn't match\n  if (cards.length === 0) {\n    cards = document.querySelectorAll('[class*=\"leafbridge\"][class*=\"product\"]');\n  }\n  \n  console.log(`[LeafBridge] Found ${cards.length} product cards`);\n  \n  cards.forEach(card => {\n    try {\n      // Product name\n      const nameEl = card.querySelector('.leafbridge_product_name, [class*=\"product_name\"]');\n      const name = nameEl?.textContent?.trim();\n      if (!name || name.length < 2) return;\n      \n      // Brand\n      const brandEl = card.querySelector('.leafbridge_brand_name, [class*=\"brand_name\"]');\n      const brand = brandEl?.textContent?.trim() || 'Unknown';\n      \n      // Price\n      const priceEl = card.querySelector('.leafbridge_product_price, [class*=\"price\"]');\n      const priceText = priceEl?.textContent || '';\n      const priceMatch = priceText.match(/\\$?(\\d+(?:\\.\\d{1,2})?)/);\n      const price = priceMatch ? parseFloat(priceMatch[1]) : 0;\n      \n      if (price <= 0) return; // Skip invalid products\n      \n      // Stock status\n      const soldOut = !!card.querySelector('.add_to_cart_soldout, [class*=\"soldout\"], [class*=\"sold-out\"]');\n      \n      // Quantity from input max attribute\n      const qtyInput = card.querySelector('input[type=\"number\"]') as HTMLInputElement | null;\n      let quantity: number | null = null;\n      let quantityWarning: string | null = null;\n      let quantitySource = 'none';\n      \n      if (qtyInput && qtyInput.max) {\n        const maxVal = parseInt(qtyInput.max, 10);\n        if (maxVal > 0 && maxVal < 100) {\n          quantity = maxVal;\n          quantitySource = 'leafbridge_input_max';\n          if (maxVal <= 5) {\n            quantityWarning = `Only ${maxVal} left`;\n          }\n        }\n      }\n      \n      // Low stock warning element\n      const lowStockEl = card.querySelector('.add_to_cart_warning, [class*=\"low-stock\"], [class*=\"warning\"]');\n      if (lowStockEl && !quantityWarning) {\n        const warningText = lowStockEl.textContent?.trim() || '';\n        if (warningText) {\n          quantityWarning = warningText;\n          const numMatch = warningText.match(/(\\d+)/);\n          if (numMatch && quantity === null) {\n            quantity = parseInt(numMatch[1], 10);\n            quantitySource = 'warning_text';\n          }\n        }\n      }\n      \n      // If sold out, set quantity to 0\n      if (soldOut) {\n        quantity = 0;\n        quantityWarning = 'Sold out';\n        quantitySource = 'sold_out_class';\n      }\n      \n      // Category\n      const categoryEl = card.querySelector('[class*=\"category\"]');\n      const rawCategory = categoryEl?.textContent?.trim();\n      \n      products.push({\n        rawProductName: name,\n        rawBrandName: brand,\n        rawCategory,\n        price,\n        inStock: !soldOut,\n        quantity,\n        quantityWarning,\n        quantitySource,\n        sourceUrl,\n        sourcePlatform: 'leafbridge',\n        scrapedAt: timestamp,\n      });\n    } catch (e) {\n      // Skip malformed cards\n      console.log('[LeafBridge] Error parsing card:', e);\n    }\n  });\n  \n  return products;\n}\n", "/**\n * CannaSignal Cron Orchestrator Worker\n * \n * Triggers every 15 minutes to:\n * 1. Fetch all active embedded-dutchie retailers\n * 2. Scrape each location via BrowserBase (CDP over WebSocket)\n * 3. Visit product detail pages to extract \"X left\" inventory counts\n * 4. Post results to Convex ingestion\n * 5. Trigger delta detection\n * 6. Send Discord notifications for inventory changes\n * \n * RESILIENCE IMPROVEMENTS (workflow-qa):\n * - Per-location retry with exponential backoff\n * - Circuit breaker for BrowserBase connection\n * - Retry logic for Convex ingestion\n * - Discord webhook retry with backoff\n * \n * v3.2.0 - Added product detail page inventory extraction\n *          - Extracts \"X left\" from product pages\n *          - Implements cart hack fallback\n *          - Samples ~30-50 products per location for speed\n * \n * v3.3.0 - Speed optimizations (P0 improvements)\n *          - Reduced page load waits: 5s\u21923s, 3s\u21922s, 4s\u21921.5s\n *          - Reduced cart hack wait: 1s\u21920.5s\n *          - Added batch processing structure for future parallelization\n *          - Expected improvement: ~40% faster scraping\n *          - Before: ~30 min for 10 locations \u00D7 40 products\n *          - After:  ~18 min estimated\n * \n * v3.4.0 - TRUE Parallel Product Page Visits (Phase 2 Optimizations)\n *          - Creates 4 concurrent browser pages per session\n *          - Products are visited in parallel batches of 4\n *          - Expected improvement: ~3-4x faster product detail extraction\n *          - Before: ~15 min (v3.3.0 with sequential visits)\n *          - After:  ~4-5 min with 4x parallelization\n *          - GraphQL interception explored (see scripts/graphql-analysis.md)\n * \n * Deployed at: cannasignal-cron.prtl.workers.dev\n * Cron schedule: every 15 minutes\n */\n\nimport { BrowserSession, CDPPage, CDPClient } from '../lib/cdp';\nimport { withRetry, fetchWithRetry, withCircuitBreaker, sleep } from '../lib/retry';\nimport { isTymberSite, fetchAndScrapeTymber } from '../lib/platforms/tymber';\nimport { \n  isLeafBridgeSite, \n  extractLeafBridgeProductsFromDOM, \n  LEAFBRIDGE_SELECTORS,\n  LEAFBRIDGE_WAIT_SELECTOR,\n  LEAFBRIDGE_AJAX_WAIT_MS,\n} from '../lib/platforms/leafbridge';\n\n// ============================================================\n// PARALLEL PAGE MANAGER (v3.4.0 - True Parallelization)\n// ============================================================\n\ninterface PagePool {\n  pages: CDPPage[];\n  session: BrowserSession;\n}\n\n/**\n * Creates a pool of browser pages for parallel scraping (v3.4.0)\n * Uses BrowserSession.createPage() to spawn additional pages within the same session\n */\nasync function createPagePool(session: BrowserSession, count: number): Promise<PagePool> {\n  const pages: CDPPage[] = [];\n  \n  // The main page is page 0\n  const mainPage = session.getPage();\n  if (mainPage) {\n    pages.push(mainPage);\n  }\n  \n  // Create additional pages for parallelization\n  for (let i = pages.length; i < count; i++) {\n    try {\n      const page = await session.createPage();\n      pages.push(page);\n      console.log(`[Cron] Created parallel page ${i + 1}/${count}`);\n    } catch (error) {\n      console.log(`[Cron] Failed to create page ${i + 1}/${count}: ${error instanceof Error ? error.message : 'Unknown'}`);\n      // Continue with fewer pages if some fail\n      break;\n    }\n  }\n  \n  console.log(`[Cron] Page pool ready: ${pages.length} concurrent pages`);\n  return { pages, session };\n}\n\n/**\n * Closes extra pages in the pool (keeps main page)\n */\nasync function closePagePool(pool: PagePool): Promise<void> {\n  // Close all pages except the first (main page - managed by session)\n  for (let i = 1; i < pool.pages.length; i++) {\n    try {\n      await pool.pages[i].close();\n    } catch {\n      // Ignore close errors\n    }\n  }\n}\n\n/**\n * Process product detail pages in parallel using page pool (v3.4.0)\n * Each page in the pool handles one product concurrently\n */\nasync function processProductsInParallel(\n  products: ScrapedProduct[],\n  pool: PagePool,\n  extractFn: typeof extractInventoryFromDetailPage,\n  cartHackFn: typeof attemptCartHack,\n  enableCartHack: boolean,\n  maxCartHackAttempts: number,\n  inventoryStats: { checked: number; found: number }\n): Promise<void> {\n  const batchSize = pool.pages.length;\n  let cartHackAttempts = 0;\n  \n  for (let batchStart = 0; batchStart < products.length; batchStart += batchSize) {\n    const batch = products.slice(batchStart, batchStart + batchSize);\n    \n    // Process batch in TRUE parallel - each page handles one product\n    const batchPromises = batch.map(async (product, batchIdx) => {\n      if (!product.productUrl) return;\n      \n      const page = pool.pages[batchIdx];\n      if (!page) return;\n      \n      try {\n        inventoryStats.checked++;\n        \n        // Navigate to product detail page\n        await page.navigate(product.productUrl);\n        await page.waitForTimeout(PAGE_RENDER_WAIT_MS);\n        \n        // Extract inventory from detail page\n        const detailData = await page.evaluateFunction(extractFn);\n        \n        // Update product with extracted data\n        if (detailData.quantity !== null) {\n          product.quantity = detailData.quantity;\n          product.quantityWarning = detailData.quantityWarning;\n          product.quantitySource = detailData.quantitySource;\n          product.inStock = detailData.inStock;\n          inventoryStats.found++;\n          console.log(`[Cron] \u2713 ${product.rawProductName.slice(0, 30)}: ${detailData.quantity} left`);\n        } else if (enableCartHack && cartHackAttempts < maxCartHackAttempts) {\n          // Try cart hack as fallback - only for first few products\n          cartHackAttempts++;\n          \n          await page.waitForTimeout(500);\n          \n          const cartResult = await page.evaluateFunction(cartHackFn);\n          \n          if (cartResult.success && cartResult.quantity !== null) {\n            product.quantity = cartResult.quantity;\n            product.quantityWarning = cartResult.quantityWarning;\n            product.quantitySource = 'cart_hack';\n            inventoryStats.found++;\n            console.log(`[Cron] \u2713 ${product.rawProductName.slice(0, 30)}: ${cartResult.quantity} via cart`);\n          }\n        }\n        \n      } catch (detailError) {\n        // Non-fatal: continue to next product\n        console.log(`[Cron] \u2717 ${product.rawProductName.slice(0, 25)}: ${detailError instanceof Error ? detailError.message.slice(0, 40) : 'Error'}`);\n      }\n    });\n    \n    // Wait for all products in this batch to complete IN PARALLEL\n    await Promise.all(batchPromises);\n    \n    // Brief pause between batches for rate limiting\n    if (batchStart + batchSize < products.length) {\n      await sleep(BATCH_DELAY_MS);\n    }\n  }\n}\n\ninterface Env {\n  BROWSERBASE_API_KEY: string;\n  BROWSERBASE_PROJECT_ID: string;\n  CONVEX_URL: string;\n  DISCORD_WEBHOOK_URL: string;\n}\n\ninterface Location {\n  name: string;\n  menuUrl: string;\n  retailerSlug: string;\n  retailerName: string;\n  address: { city: string; state: string; street?: string };\n  region: string;\n  // Multi-location support\n  disabled?: boolean;         // Skip this location temporarily\n  disabledReason?: string;    // Why it's disabled\n}\n\ninterface ScrapedProduct {\n  rawProductName: string;\n  rawBrandName: string;\n  rawCategory?: string;\n  price: number;\n  originalPrice?: number;\n  inStock: boolean;\n  quantity: number | null;              // Actual inventory count (null = unknown)\n  quantityWarning: string | null;       // Raw warning text e.g., \"3 left\"\n  quantitySource: string;               // \"text_pattern\" | \"cart_hack\" | \"inferred\" | \"none\"\n  imageUrl?: string;\n  thcFormatted?: string;\n  cbdFormatted?: string;\n  sourceUrl: string;\n  sourcePlatform: string;\n  scrapedAt: number;\n  // Product detail page specific\n  productUrl?: string;                  // URL of the product detail page\n}\n\n// ============================================================\n// CONFIGURATION (v3.3.0 - Parallelization & Speed Optimizations)\n// ============================================================\n\n// Max products to visit detail pages for per location (speed optimization)\nconst MAX_DETAIL_PAGE_VISITS_PER_LOCATION = 40;\n\n// Number of parallel pages/tabs to use for product detail visits\n// Higher = faster but more resource intensive on BrowserBase\nconst PARALLEL_PAGE_COUNT = 4;\n\n// Timeout for product detail page load (ms) - REDUCED from 8000\nconst DETAIL_PAGE_TIMEOUT_MS = 4000;\n\n// Time to wait for page content to render after navigation (ms)\nconst PAGE_RENDER_WAIT_MS = 1500;\n\n// Delay between batches of parallel visits (rate limiting)\nconst BATCH_DELAY_MS = 500;\n\n// Whether to enable cart hack fallback (slower but more thorough)\nconst ENABLE_CART_HACK_FALLBACK = true;\n\n// Max products to apply cart hack to (very slow operation)\nconst MAX_CART_HACK_ATTEMPTS = 3;\n\n// ============================================================\n// EMBEDDED LOCATIONS (2026-02-24 Update)\n// \n// Focus on VERIFIED WORKING embedded sites only.\n// Disabled all sites with ERR_CONNECTION_RESET or bot detection.\n// \n// Working: Dagmar, Strain Stars, Travel Agency, Alta (LeafBridge)\n// Blocked: CONBUD (IP block), Gotham (intermittent), direct Dutchie URLs\n// Pending: Housing Works (needs Tymber selectors - SCRAPE-007)\n// ============================================================\n\nconst EMBEDDED_LOCATIONS: Location[] = [\n  // ============================================================\n  // VERIFIED WORKING (4 sites, ~156 products)\n  // ============================================================\n  \n  // Dagmar (1 location) \u2705 VERIFIED - WordPress Joint-Dutchie plugin\n  { name: \"Dagmar Cannabis SoHo\", menuUrl: \"https://dagmarcannabis.com/menu/\", retailerSlug: \"dagmar-cannabis-soho\", retailerName: \"Dagmar Cannabis\", address: { street: \"412 W Broadway\", city: \"New York\", state: \"NY\" }, region: \"nyc\" },\n  \n  // Strain Stars (1 active location) \u2705 VERIFIED - Custom embedded\n  { name: \"Strain Stars Farmingdale\", menuUrl: \"https://strainstarsny.com/menu/\", retailerSlug: \"strain-stars-farmingdale\", retailerName: \"Strain Stars\", address: { street: \"1815 Broadhollow Rd\", city: \"Farmingdale\", state: \"NY\" }, region: \"long_island\" },\n  { name: \"Strain Stars Riverhead\", menuUrl: \"https://strainstarsny.com/menu/\", retailerSlug: \"strain-stars-riverhead\", retailerName: \"Strain Stars\", address: { street: \"1871 Old Country Rd\", city: \"Riverhead\", state: \"NY\" }, region: \"long_island\", disabled: true, disabledReason: \"shared-url-no-selector\" },\n  \n  // Travel Agency (1 location) \u2705 VERIFIED - SSR custom frontend\n  { name: \"Travel Agency Union Square\", menuUrl: \"https://www.thetravelagency.co/menu/\", retailerSlug: \"travel-agency-union-square\", retailerName: \"The Travel Agency\", address: { street: \"835 Broadway\", city: \"New York\", state: \"NY\" }, region: \"nyc\" },\n  \n  // Alta (1 location) \u2705 VERIFIED - LeafBridge platform (not Dutchie!)\n  // Added by scraper loop SCRAPE-006\n  { name: \"Alta Lower Manhattan\", menuUrl: \"https://altadispensary.nyc/\", retailerSlug: \"alta-lower-manhattan\", retailerName: \"Alta Dispensary\", address: { street: \"52 Kenmare St A\", city: \"New York\", state: \"NY\", zip: \"10012\" }, region: \"nyc\" },\n  \n  // ============================================================\n  // PENDING - Needs custom selectors\n  // ============================================================\n  \n  // Housing Works - Tymber platform (SSR, products in HTML)\n  // Uses different selectors than Dutchie: [class*='product-card__name'], [class*='product-card__brand-name']\n  // Re-enabled to test with residential proxies - may need custom scraper\n  { name: \"Housing Works Cannabis\", menuUrl: \"https://hwcannabis.co/menu/broadway/\", retailerSlug: \"housing-works-cannabis\", retailerName: \"Housing Works Cannabis\", address: { street: \"750 Broadway\", city: \"New York\", state: \"NY\" }, region: \"nyc\" },\n  \n  // Smacked - Re-enabled to test with residential proxies\n  { name: \"Smacked Village\", menuUrl: \"https://getsmacked.online/menu/\", retailerSlug: \"smacked-village\", retailerName: \"Get Smacked\", address: { street: \"144 Bleecker St\", city: \"New York\", state: \"NY\" }, region: \"nyc\" },\n  \n  // ============================================================\n  // RE-ENABLED WITH RESIDENTIAL PROXIES (2026-02-24)\n  // BrowserBase proxies=true bypasses datacenter IP detection\n  // ============================================================\n  \n  // CONBUD (3 locations) - Major NYC retailer, re-enabled with residential proxies\n  { name: \"CONBUD LES\", menuUrl: \"https://conbud.com/stores/conbud-les/products\", retailerSlug: \"conbud-les\", retailerName: \"CONBUD\", address: { street: \"88 E Houston St\", city: \"New York\", state: \"NY\" }, region: \"nyc\" },\n  { name: \"CONBUD Bronx\", menuUrl: \"https://conbud.com/stores/conbud-bronx/products\", retailerSlug: \"conbud-bronx\", retailerName: \"CONBUD\", address: { city: \"Bronx\", state: \"NY\" }, region: \"nyc\" },\n  { name: \"CONBUD Yankee Stadium\", menuUrl: \"https://conbud.com/stores/conbud-yankee-stadium/products\", retailerSlug: \"conbud-yankee-stadium\", retailerName: \"CONBUD\", address: { city: \"Bronx\", state: \"NY\" }, region: \"nyc\" },\n  \n  // Gotham (1 active + 3 shared-URL) - Major NYC retailer, re-enabled with residential proxies\n  { name: \"Gotham Bowery\", menuUrl: \"https://gotham.nyc/menu/\", retailerSlug: \"gotham-bowery\", retailerName: \"Gotham\", address: { street: \"3 E 3rd St\", city: \"New York\", state: \"NY\" }, region: \"nyc\" },\n  { name: \"Gotham Hudson\", menuUrl: \"https://gotham.nyc/menu/\", retailerSlug: \"gotham-hudson\", retailerName: \"Gotham\", address: { street: \"260 Warren St\", city: \"Hudson\", state: \"NY\" }, region: \"hudson_valley\", disabled: true, disabledReason: \"shared-url-no-selector\" },\n  { name: \"Gotham Williamsburg\", menuUrl: \"https://gotham.nyc/menu/\", retailerSlug: \"gotham-williamsburg\", retailerName: \"Gotham\", address: { street: \"300 Kent Ave\", city: \"Brooklyn\", state: \"NY\" }, region: \"nyc\", disabled: true, disabledReason: \"shared-url-no-selector\" },\n  { name: \"Gotham Chelsea\", menuUrl: \"https://gotham.nyc/menu/\", retailerSlug: \"gotham-chelsea\", retailerName: \"Gotham\", address: { street: \"146 10th Ave\", city: \"New York\", state: \"NY\" }, region: \"nyc\", disabled: true, disabledReason: \"shared-url-no-selector\" },\n  \n  // ============================================================\n  // BROKEN URLs (404 / offline)\n  // ============================================================\n  \n  // Just Breathe - Syracuse & Binghamton return 404\n  { name: \"Just Breathe Syracuse\", menuUrl: \"https://justbreathelife.org/menu/\", retailerSlug: \"just-breathe-syracuse\", retailerName: \"Just Breathe\", address: { street: \"185 W Seneca St\", city: \"Manlius\", state: \"NY\" }, region: \"upstate\", disabled: true, disabledReason: \"url-404\" },\n  { name: \"Just Breathe Binghamton\", menuUrl: \"https://justbreathelife.org/menu/\", retailerSlug: \"just-breathe-binghamton\", retailerName: \"Just Breathe\", address: { street: \"75 Court St\", city: \"Binghamton\", state: \"NY\" }, region: \"upstate\", disabled: true, disabledReason: \"url-404\" },\n  { name: \"Just Breathe Finger Lakes\", menuUrl: \"https://justbreatheflx.com/\", retailerSlug: \"just-breathe-finger-lakes\", retailerName: \"Just Breathe\", address: { street: \"2988 US Route 20\", city: \"Seneca Falls\", state: \"NY\" }, region: \"upstate\", disabled: true, disabledReason: \"needs-verification\" },\n];\n\n// Get active locations (not disabled)\nfunction getActiveLocations(): Location[] {\n  return EMBEDDED_LOCATIONS.filter(l => !l.disabled);\n}\n\n// ============================================================\n// BROWSERBASE CONNECTION (with circuit breaker + retry - CRIT-005)\n// ============================================================\n\n// Enable residential proxies to bypass datacenter IP blocking (2026-02-24)\n// This helps with CONBUD, Gotham, and other sites that block datacenter IPs\nconst USE_RESIDENTIAL_PROXIES = true;\n\nasync function createBrowserSession(env: Env): Promise<BrowserSession> {\n  return withCircuitBreaker('browserbase', async () => {\n    return withRetry(\n      async () => {\n        console.log(`[Cron] Connecting to BrowserBase via CDP... (proxies: ${USE_RESIDENTIAL_PROXIES ? 'RESIDENTIAL' : 'datacenter'})`);\n        const session = new BrowserSession(\n          env.BROWSERBASE_API_KEY,\n          env.BROWSERBASE_PROJECT_ID,\n          {\n            debug: false,\n            proxies: USE_RESIDENTIAL_PROXIES,\n            proxyGeolocation: 'US-NY', // New York for NYC dispensaries\n          }\n        );\n        await session.init();\n        console.log('[Cron] Connected to BrowserBase');\n        return session;\n      },\n      {\n        maxRetries: 3,\n        baseDelayMs: 2000,\n        onRetry: (attempt, error, delay) => {\n          console.log(`[Cron] BrowserBase retry ${attempt}: ${error.message}, waiting ${delay}ms`);\n        }\n      }\n    );\n  }, {\n    failureThreshold: 3,\n    resetTimeMs: 120000, // 2 minutes before retry after circuit opens\n    halfOpenRequests: 1,\n  });\n}\n\n// ============================================================\n// PRODUCT URL EXTRACTION (runs in browser context)\n// \n// Dutchie product detail URLs follow the pattern:\n// /stores/{store-slug}/product/{product-slug}\n// Note: This is different from category pages which use /products/\n// ============================================================\n\nfunction extractProductUrls(): { name: string; url: string }[] {\n  const productLinks: { name: string; url: string }[] = [];\n  const seen = new Set<string>();\n  \n  // Find links matching product detail pattern (singular /product/, not /products/)\n  const productLinkEls = document.querySelectorAll('a[href*=\"/product/\"]') as NodeListOf<HTMLAnchorElement>;\n  \n  productLinkEls.forEach((link) => {\n    const href = link.href;\n    \n    // Only include actual product detail pages (contains /product/ but not /products/)\n    if (href && !seen.has(href) && href.includes('/product/') && !href.includes('/products/')) {\n      seen.add(href);\n      \n      // Get product name from the link text or nearby elements\n      const text = link.textContent?.trim() || \n                  link.closest('div')?.querySelector('h2, h3, [class*=\"name\"], [class*=\"Name\"]')?.textContent?.trim() || '';\n      \n      // Only include if we have meaningful text or a valid URL\n      if (text.length > 2 || href.length > 50) {\n        productLinks.push({ name: text || 'Unknown', url: href });\n      }\n    }\n  });\n  \n  // Fallback: try to find product cards with links\n  if (productLinks.length === 0) {\n    const cards = document.querySelectorAll('[data-testid=\"product-card\"], [class*=\"ProductCard\"], [class*=\"product-card\"]');\n    cards.forEach((card) => {\n      const link = card.querySelector('a[href*=\"/product/\"]') as HTMLAnchorElement | null;\n      if (link && link.href && !seen.has(link.href) && !link.href.includes('/products/')) {\n        seen.add(link.href);\n        const name = card.querySelector('h2, h3, [class*=\"productName\"]')?.textContent?.trim() || '';\n        productLinks.push({ name: name || 'Unknown', url: link.href });\n      }\n    });\n  }\n  \n  return productLinks;\n}\n\n// ============================================================\n// PRODUCT DETAIL PAGE INVENTORY EXTRACTION\n// ============================================================\n\nfunction extractInventoryFromDetailPage(): {\n  quantity: number | null;\n  quantityWarning: string | null;\n  quantitySource: string;\n  productName: string | null;\n  price: number | null;\n  thcFormatted: string | null;\n  inStock: boolean;\n} {\n  const bodyText = document.body.innerText || '';\n  \n  // Primary pattern: \"X left\" (proven to work on Dutchie product pages)\n  const stockPatterns = [\n    /(\\d+)\\s*left/i,\n    /only\\s*(\\d+)\\s*left/i,\n    /(\\d+)\\s*left\\s*in\\s*stock/i,\n    /(\\d+)\\s*remaining/i,\n    /(\\d+)\\s*available/i,\n    /(\\d+)\\s*in\\s*stock/i,\n    /hurry[,!]?\\s*only\\s*(\\d+)/i,\n    /limited[:\\s]*(\\d+)/i,\n    /low\\s*stock[:\\s]*(\\d+)/i,\n  ];\n  \n  let quantity: number | null = null;\n  let quantityWarning: string | null = null;\n  let quantitySource = 'none';\n  \n  for (const pattern of stockPatterns) {\n    const match = bodyText.match(pattern);\n    if (match) {\n      quantity = parseInt(match[1], 10);\n      quantityWarning = match[0].trim();\n      quantitySource = 'text_pattern';\n      break;\n    }\n  }\n  \n  // Check for out of stock indicators\n  const outOfStockPatterns = [\n    /out\\s*of\\s*stock/i,\n    /sold\\s*out/i,\n    /unavailable/i,\n    /not\\s*available/i,\n  ];\n  \n  let inStock = true;\n  for (const pattern of outOfStockPatterns) {\n    if (pattern.test(bodyText)) {\n      inStock = false;\n      quantity = 0;\n      quantityWarning = 'Out of stock';\n      quantitySource = 'text_pattern';\n      break;\n    }\n  }\n  \n  // Extract product name from page\n  const nameEl = document.querySelector('h1, [class*=\"ProductName\"], [class*=\"product-name\"], [class*=\"productTitle\"]');\n  const productName = nameEl?.textContent?.trim() || null;\n  \n  // Extract price\n  let price: number | null = null;\n  const priceMatch = bodyText.match(/\\$(\\d+(?:\\.\\d{1,2})?)/);\n  if (priceMatch) {\n    price = parseFloat(priceMatch[1]);\n  }\n  \n  // Extract THC\n  let thcFormatted: string | null = null;\n  const thcMatch = bodyText.match(/THC[:\\s]*(\\d+(?:\\.\\d+)?)\\s*%/i);\n  if (thcMatch) {\n    thcFormatted = `${thcMatch[1]}%`;\n  }\n  \n  return {\n    quantity,\n    quantityWarning,\n    quantitySource,\n    productName,\n    price,\n    thcFormatted,\n    inStock,\n  };\n}\n\n// ============================================================\n// CART HACK FALLBACK (in browser context)\n// ============================================================\n\nfunction attemptCartHack(): { quantity: number | null; quantityWarning: string | null; success: boolean } {\n  // Find add to cart button\n  const addButtons = document.querySelectorAll(\n    'button:not([disabled])'\n  );\n  \n  let addButton: HTMLButtonElement | null = null;\n  addButtons.forEach((btn) => {\n    const text = btn.textContent?.toLowerCase() || '';\n    if (text.includes('add') && (text.includes('cart') || text.includes('bag') || btn.textContent?.length! < 20)) {\n      addButton = btn as HTMLButtonElement;\n    }\n  });\n  \n  if (!addButton) {\n    return { quantity: null, quantityWarning: null, success: false };\n  }\n  \n  // Look for quantity input\n  const qtyInput = document.querySelector('input[type=\"number\"], input[name*=\"qty\"], input[name*=\"quantity\"]') as HTMLInputElement | null;\n  \n  if (qtyInput) {\n    // Set high value to trigger limit\n    const originalValue = qtyInput.value;\n    qtyInput.value = '999';\n    qtyInput.dispatchEvent(new Event('input', { bubbles: true }));\n    qtyInput.dispatchEvent(new Event('change', { bubbles: true }));\n    \n    // Check for immediate validation error\n    const pageText = document.body.innerText || '';\n    \n    // Look for error messages about limits\n    const limitPatterns = [\n      /max(?:imum)?\\s*(?:of\\s*)?(\\d+)/i,\n      /limit(?:ed)?\\s*(?:to\\s*)?(\\d+)/i,\n      /only\\s*(\\d+)\\s*(?:available|remaining|left)/i,\n      /cannot\\s*add\\s*more\\s*than\\s*(\\d+)/i,\n      /(\\d+)\\s*(?:items?\\s*)?(?:maximum|max|limit)/i,\n    ];\n    \n    for (const pattern of limitPatterns) {\n      const match = pageText.match(pattern);\n      if (match) {\n        // Reset the input\n        qtyInput.value = originalValue;\n        return {\n          quantity: parseInt(match[1], 10),\n          quantityWarning: match[0].trim(),\n          success: true,\n        };\n      }\n    }\n    \n    // Check if input was auto-corrected\n    const correctedValue = parseInt(qtyInput.value, 10);\n    if (correctedValue > 0 && correctedValue < 999) {\n      qtyInput.value = originalValue;\n      return {\n        quantity: correctedValue,\n        quantityWarning: `Max quantity: ${correctedValue}`,\n        success: true,\n      };\n    }\n    \n    // Reset\n    qtyInput.value = originalValue;\n  }\n  \n  // Check for max attribute on input\n  const maxAttr = qtyInput?.max;\n  if (maxAttr) {\n    const maxVal = parseInt(maxAttr, 10);\n    if (maxVal > 0 && maxVal < 100) {\n      return {\n        quantity: maxVal,\n        quantityWarning: `Max: ${maxVal}`,\n        success: true,\n      };\n    }\n  }\n  \n  // Check for select dropdown with quantity options\n  const qtySelect = document.querySelector('select[name*=\"qty\"], select[name*=\"quantity\"]') as HTMLSelectElement | null;\n  if (qtySelect && qtySelect.options.length > 0) {\n    const options = Array.from(qtySelect.options)\n      .map(o => parseInt(o.value, 10))\n      .filter(n => !isNaN(n) && n > 0);\n    \n    if (options.length > 0) {\n      const maxOption = Math.max(...options);\n      if (maxOption < 50) { // Likely inventory-capped\n        return {\n          quantity: maxOption,\n          quantityWarning: `Max qty: ${maxOption}`,\n          success: true,\n        };\n      }\n    }\n  }\n  \n  return { quantity: null, quantityWarning: null, success: false };\n}\n\n// ============================================================\n// CATEGORY PAGE PRODUCT EXTRACTION (runs in browser context)\n// ============================================================\n\nfunction extractProducts(sourceUrl: string, timestamp: number): ScrapedProduct[] {\n  const items: ScrapedProduct[] = [];\n  \n  // Multiple selector patterns for different Dutchie embed types\n  const selectors = [\n    '[data-testid=\"product-card\"]',\n    '.product-card',\n    '[class*=\"ProductCard\"]',\n    '[class*=\"product-card\"]',\n    'div[class*=\"styles_productCard\"]',\n  ];\n  \n  let productCards: Element[] = [];\n  for (const selector of selectors) {\n    const found = document.querySelectorAll(selector);\n    if (found.length > 0) {\n      productCards = Array.from(found);\n      break;\n    }\n  }\n  \n  // Fallback: find via price elements\n  if (productCards.length === 0) {\n    const priceEls = document.querySelectorAll('[class*=\"price\"], [class*=\"Price\"]');\n    const seen = new Set<Element>();\n    priceEls.forEach(priceEl => {\n      const card = priceEl.closest('a') || priceEl.closest('div[class*=\"product\"]') || priceEl.parentElement?.parentElement;\n      if (card && !seen.has(card)) {\n        seen.add(card);\n        productCards.push(card);\n      }\n    });\n  }\n  \n  productCards.forEach((card) => {\n    try {\n      // Product name\n      const nameEl = card.querySelector('h2, h3, [class*=\"productName\"], [class*=\"ProductName\"], [class*=\"name\"]');\n      const name = nameEl?.textContent?.trim();\n      if (!name || name.length < 3) return;\n      \n      // Brand\n      const brandEl = card.querySelector('[class*=\"brandName\"], [class*=\"BrandName\"], [class*=\"brand\"]');\n      const brand = brandEl?.textContent?.trim() || \"Unknown\";\n      \n      // Price extraction - FIXED: flexible decimal handling & better selectors\n      const currentPriceSelectors = [\n        '[class*=\"DiscountedPrice\"]',\n        '[class*=\"SalePrice\"]',\n        '[class*=\"CurrentPrice\"]',\n        '[class*=\"FinalPrice\"]',\n      ];\n      const genericPriceSelectors = [\n        '[class*=\"price\"]:not([class*=\"original\"]):not([class*=\"strikethrough\"])',\n        '[class*=\"Price\"]:not([class*=\"Original\"]):not([class*=\"Strikethrough\"])',\n        '.price',\n        '[data-testid*=\"price\"]',\n      ];\n      \n      let price = 0;\n      \n      for (const sel of [...currentPriceSelectors, ...genericPriceSelectors]) {\n        const el = card.querySelector(sel);\n        if (el && el.textContent) {\n          const match = el.textContent.match(/\\$(\\d+(?:\\.\\d{1,2})?)/);\n          if (match) {\n            price = parseFloat(match[1]);\n            if (price > 0) break;\n          }\n        }\n      }\n      \n      // Fallback: scan card text for any price pattern\n      if (!price) {\n        const cardText = card.textContent || '';\n        const allPrices = [...cardText.matchAll(/\\$(\\d+(?:\\.\\d{1,2})?)/g)]\n          .map(m => parseFloat(m[1]))\n          .filter(p => p > 0);\n        if (allPrices.length > 0) {\n          price = Math.min(...allPrices);\n        }\n      }\n      \n      // Original price (for sales)\n      const origPriceEl = card.querySelector('[class*=\"original\"], [class*=\"strikethrough\"], [class*=\"Original\"], del, s');\n      let originalPrice: number | undefined;\n      if (origPriceEl) {\n        const origMatch = origPriceEl.textContent?.match(/\\$?(\\d+(?:\\.\\d{1,2})?)/);\n        if (origMatch) {\n          const parsedOrig = parseFloat(origMatch[1]);\n          if (parsedOrig > price) {\n            originalPrice = parsedOrig;\n          }\n        }\n      }\n      \n      // Category\n      const categoryEl = card.querySelector('[class*=\"category\"]');\n      const category = categoryEl?.textContent?.trim();\n      \n      // Image\n      const imgEl = card.querySelector('img');\n      const imageUrl = imgEl?.src;\n      \n      // Stock status & Quantity detection from listing page\n      const stockEl = card.querySelector('[class*=\"outOfStock\"], [class*=\"soldOut\"], [class*=\"OutOfStock\"], [class*=\"SoldOut\"], [class*=\"unavailable\"]');\n      let inStock = !stockEl;\n      let quantity: number | null = null;\n      let quantityWarning: string | null = null;\n      let quantitySource = 'none';\n      \n      if (stockEl) {\n        inStock = false;\n        quantity = 0;\n        quantityWarning = stockEl.textContent?.trim() || 'Out of stock';\n        quantitySource = 'text_pattern';\n      }\n      \n      // Look for quantity warnings on listing page\n      if (inStock) {\n        const cardText = card.textContent || '';\n        \n        const quantityPatterns = [\n          /only\\s*(\\d+)\\s*left/i,\n          /(\\d+)\\s*left\\s*(?:in\\s*stock)?/i,\n          /(\\d+)\\s*remaining/i,\n          /limited[:\\s]*(\\d+)/i,\n          /low\\s*stock[:\\s]*(\\d+)/i,\n          /(\\d+)\\s*available/i,\n          /hurry[,!]?\\s*only\\s*(\\d+)/i,\n        ];\n        \n        for (const pattern of quantityPatterns) {\n          const match = cardText.match(pattern);\n          if (match) {\n            quantity = parseInt(match[1], 10);\n            quantityWarning = match[0].trim();\n            quantitySource = 'text_pattern';\n            break;\n          }\n        }\n        \n        if (!quantityWarning) {\n          const lowStockEl = card.querySelector('[class*=\"LowStock\"], [class*=\"low-stock\"], [class*=\"StockWarning\"], [class*=\"stock-warning\"]');\n          if (lowStockEl) {\n            quantityWarning = lowStockEl.textContent?.trim() || 'Low stock';\n            const numMatch = quantityWarning.match(/(\\d+)/);\n            if (numMatch) {\n              quantity = parseInt(numMatch[1], 10);\n              quantitySource = 'text_pattern';\n            }\n          } else if (/low\\s*stock/i.test(cardText)) {\n            quantityWarning = 'Low stock';\n          }\n        }\n      }\n      \n      // Extract product URL for detail page visits\n      // Look for links with /product/ pattern (product detail pages)\n      const productLinkEl = card.querySelector('a[href*=\"/product/\"]') || card.querySelector('a') || card.closest('a');\n      let productUrl: string | undefined = undefined;\n      if (productLinkEl) {\n        const href = (productLinkEl as HTMLAnchorElement).href;\n        // Only use URLs that are actual product detail pages (contain /product/ but not /products/)\n        if (href && href.includes('/product/') && !href.includes('/products/')) {\n          productUrl = href;\n        }\n      }\n      \n      // THC/CBD\n      const thcEl = card.querySelector('[class*=\"thc\"], [class*=\"THC\"]');\n      const cbdEl = card.querySelector('[class*=\"cbd\"], [class*=\"CBD\"]');\n      const thcFormatted = thcEl?.textContent?.trim();\n      const cbdFormatted = cbdEl?.textContent?.trim();\n      \n      if (price > 0) {\n        items.push({\n          rawProductName: name,\n          rawBrandName: brand,\n          rawCategory: category,\n          price,\n          originalPrice,\n          inStock,\n          quantity,\n          quantityWarning,\n          quantitySource,\n          imageUrl,\n          thcFormatted,\n          cbdFormatted,\n          sourceUrl,\n          productUrl,\n          sourcePlatform: \"dutchie-embedded\",\n          scrapedAt: timestamp,\n        });\n      }\n    } catch (e) {\n      // Skip malformed cards\n    }\n  });\n  \n  return items;\n}\n\n// ============================================================\n// SCRAPER (with product detail page inventory extraction)\n// ============================================================\n\nasync function scrapeLocation(\n  session: BrowserSession,\n  location: Location\n): Promise<{ products: ScrapedProduct[]; error?: string; inventoryStats: { checked: number; found: number } }> {\n  const scrapedAt = Date.now();\n  const inventoryStats = { checked: 0, found: 0 };\n  \n  try {\n    // Navigate with retry\n    await withRetry(\n      async () => {\n        await session.goto(location.menuUrl);\n      },\n      {\n        maxRetries: 2,\n        baseDelayMs: 2000,\n        onRetry: (attempt, error) => {\n          console.log(`[Cron] Navigation retry ${attempt} for ${location.name}: ${error.message}`);\n        }\n      }\n    );\n    \n    // Wait for content to render - REDUCED from 5000ms (v3.3.0)\n    await session.waitForTimeout(3000);\n    \n    // Handle age verification if present\n    await session.evaluate(`\n      const buttons = document.querySelectorAll('button');\n      buttons.forEach(btn => {\n        const text = btn.textContent?.trim().toLowerCase() || '';\n        if (text === 'yes' || text === 'i am 21' || text.includes('21+') || text.includes('enter') || text === 'i agree') {\n          btn.click();\n        }\n      });\n    `);\n    \n    // Wait for menu to load after age gate - REDUCED from 3000ms (v3.3.0)\n    await session.waitForTimeout(2000);\n    \n    // ============================================================\n    // LEAFBRIDGE CUSTOM EXTRACTION (v3.5.0)\n    // LeafBridge uses AJAX loading - needs longer wait + custom selectors\n    // Inventory is available on listing page via input[max] attribute\n    // ============================================================\n    if (isLeafBridgeSite(location.menuUrl)) {\n      console.log(`[Cron] \uD83C\uDF3F Using LeafBridge extraction for ${location.name}`);\n      \n      // Wait longer for AJAX content to load\n      await session.waitForTimeout(LEAFBRIDGE_AJAX_WAIT_MS);\n      \n      // Wait for product cards to appear\n      try {\n        await session.evaluate(`\n          // Check if LeafBridge products have loaded\n          const cards = document.querySelectorAll('${LEAFBRIDGE_WAIT_SELECTOR}');\n          if (cards.length === 0) {\n            // Try fallback selectors\n            const fallback = document.querySelectorAll('[class*=\"leafbridge\"][class*=\"product\"]');\n            console.log('[LeafBridge] Fallback found:', fallback.length);\n          }\n        `);\n      } catch (e) {\n        console.log(`[Cron] LeafBridge wait check failed, continuing...`);\n      }\n      \n      // Extract using LeafBridge-specific function\n      const products = await session.evaluateFunction<ScrapedProduct[]>(\n        extractLeafBridgeProductsFromDOM as (...args: unknown[]) => ScrapedProduct[],\n        location.menuUrl,\n        scrapedAt\n      );\n      \n      console.log(`[Cron] ${location.name}: Found ${products.length} products via LeafBridge extraction`);\n      \n      // LeafBridge products should already have inventory from input[max]\n      const withQty = products.filter(p => p.quantity !== null).length;\n      inventoryStats.checked = products.length;\n      inventoryStats.found = withQty;\n      \n      console.log(`[Cron] ${location.name}: Inventory found for ${withQty}/${products.length} products (LeafBridge listing)`);\n      \n      // Skip product detail page visits - LeafBridge has inventory on listing\n      return { products, inventoryStats };\n    }\n    \n    // ============================================================\n    // DUTCHIE/GENERIC EXTRACTION (existing flow)\n    // ============================================================\n    \n    // Extract products from category page\n    const products = await session.evaluateFunction<ScrapedProduct[]>(\n      extractProducts as (...args: unknown[]) => ScrapedProduct[],\n      location.menuUrl,\n      scrapedAt\n    );\n    \n    console.log(`[Cron] ${location.name}: Found ${products.length} products on listing page`);\n    \n    // ============================================================\n    // PRODUCT DETAIL PAGE INVENTORY EXTRACTION\n    // ============================================================\n    \n    // If products don't have URLs, extract them separately and match by name\n    const productsWithoutUrls = products.filter(p => p.inStock && p.quantity === null && !p.productUrl);\n    \n    if (productsWithoutUrls.length > 0) {\n      // Extract all product URLs from the page\n      const allProductUrls = await session.evaluateFunction<{ name: string; url: string }[]>(\n        extractProductUrls\n      );\n      \n      console.log(`[Cron] ${location.name}: Found ${allProductUrls.length} product URLs on page`);\n      \n      // Match URLs to products by name similarity\n      for (const product of productsWithoutUrls) {\n        const productNameLower = product.rawProductName.toLowerCase();\n        \n        // Find best matching URL\n        const matchedUrl = allProductUrls.find(pu => {\n          const urlNameLower = pu.name.toLowerCase();\n          // Check for substring match in either direction\n          return urlNameLower.includes(productNameLower.slice(0, 20)) || \n                 productNameLower.includes(urlNameLower.slice(0, 20)) ||\n                 // Also check URL slug\n                 pu.url.toLowerCase().includes(productNameLower.replace(/[^a-z0-9]/g, '-').slice(0, 20));\n        });\n        \n        if (matchedUrl) {\n          product.productUrl = matchedUrl.url;\n        }\n      }\n    }\n    \n    // Get products that need inventory checking (no quantity found on listing)\n    const productsNeedingInventory = products.filter(\n      p => p.inStock && p.quantity === null && p.productUrl\n    );\n    \n    // Sample products for detail page visits (speed optimization)\n    const productsToCheck = productsNeedingInventory.slice(0, MAX_DETAIL_PAGE_VISITS_PER_LOCATION);\n    \n    console.log(`[Cron] ${location.name}: Checking ${productsToCheck.length} product detail pages for inventory (parallel=${PARALLEL_PAGE_COUNT})`);\n    \n    // v3.4.0: TRUE PARALLEL PROCESSING with multiple browser pages\n    // Create a page pool for concurrent product page visits\n    if (productsToCheck.length > 0) {\n      const pagePool = await createPagePool(session, PARALLEL_PAGE_COUNT);\n      \n      try {\n        // Process all products in parallel batches using the page pool\n        await processProductsInParallel(\n          productsToCheck,\n          pagePool,\n          extractInventoryFromDetailPage,\n          attemptCartHack,\n          ENABLE_CART_HACK_FALLBACK,\n          MAX_CART_HACK_ATTEMPTS,\n          inventoryStats\n        );\n      } finally {\n        // Clean up extra pages\n        await closePagePool(pagePool);\n      }\n    }\n    \n    console.log(`[Cron] ${location.name}: Inventory found for ${inventoryStats.found}/${inventoryStats.checked} products checked`);\n    \n    return { products, inventoryStats };\n  } catch (error) {\n    return {\n      products: [],\n      error: error instanceof Error ? error.message : \"Unknown scraping error\",\n      inventoryStats,\n    };\n  }\n}\n\n// ============================================================\n// CONVEX API (with retry - CRIT-002)\n// ============================================================\n\nasync function postToConvex(\n  convexUrl: string,\n  batchId: string,\n  results: Array<{ retailerSlug: string; items: unknown[]; status: string; error?: string; attempts?: number }>\n): Promise<{ totalEventsDetected?: number }> {\n  // Strip 'attempts' field - Convex schema doesn't expect it (causes ArgumentValidationError)\n  const cleanedResults = results.map(({ attempts, ...rest }) => rest);\n  \n  const response = await fetchWithRetry(\n    `${convexUrl}/ingest/scraped-batch`,\n    {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ batchId, results: cleanedResults }),\n      timeoutMs: 60000,\n    },\n    {\n      maxRetries: 3,\n      baseDelayMs: 2000,\n      onRetry: (attempt, error, delay) => {\n        console.log(`[Cron] Convex retry ${attempt}: ${error.message}, waiting ${delay}ms`);\n      }\n    }\n  );\n  \n  if (!response.ok) {\n    const text = await response.text();\n    throw new Error(`Convex ingestion failed: ${response.status} - ${text}`);\n  }\n  \n  return response.json();\n}\n\n// ============================================================\n// DISCORD NOTIFICATIONS (with retry - CRIT-004)\n// ============================================================\n\nasync function triggerDiscordNotifications(convexUrl: string, webhookUrl: string) {\n  const response = await fetchWithRetry(\n    `${convexUrl}/events/notify`,\n    {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ webhookUrl, maxEvents: 25 }),\n      timeoutMs: 30000,\n    },\n    {\n      maxRetries: 2,\n      baseDelayMs: 1000,\n    }\n  );\n  \n  if (!response.ok) {\n    console.error(`Discord notification trigger failed: ${response.status}`);\n    return null;\n  }\n  \n  return response.json();\n}\n\ninterface DiscordEmbed {\n  title: string;\n  color: number;\n  fields: Array<{ name: string; value: string; inline: boolean }>;\n  footer?: { text: string };\n  timestamp?: string;\n}\n\nasync function sendDiscordSummary(webhookUrl: string, embed: DiscordEmbed): Promise<boolean> {\n  try {\n    const response = await fetchWithRetry(\n      webhookUrl,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ embeds: [embed] }),\n        timeoutMs: 10000,\n      },\n      {\n        maxRetries: 3,\n        baseDelayMs: 1000,\n      }\n    );\n    return response.ok;\n  } catch (error) {\n    console.error('[Cron] Discord summary failed after retries:', error);\n    return false;\n  }\n}\n\n// ============================================================\n// MAIN CRON HANDLER (with per-location retry - CRIT-001)\n// ============================================================\n\nexport default {\n  // Scheduled handler - runs every 15 minutes\n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {\n    const batchId = `batch-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n    const startTime = Date.now();\n    \n    // Get active locations only\n    const activeLocations = getActiveLocations();\n    const disabledCount = EMBEDDED_LOCATIONS.length - activeLocations.length;\n    \n    console.log(`[Cron] Starting scrape batch ${batchId}`);\n    console.log(`[Cron] Scraping ${activeLocations.length} locations (${disabledCount} disabled)`);\n    \n    let session: BrowserSession | null = null;\n    const results: Array<{\n      retailerSlug: string;\n      items: ScrapedProduct[];\n      status: string;\n      error?: string;\n      attempts: number;\n    }> = [];\n    const errors: string[] = [];\n    let totalProducts = 0;\n    let totalInventoryChecked = 0;\n    let totalInventoryFound = 0;\n    \n    try {\n      // Connect to BrowserBase (with circuit breaker + retry)\n      session = await createBrowserSession(env);\n      \n      // Scrape each active location with per-location retry (CRIT-001)\n      for (const location of activeLocations) {\n        let attempts = 0;\n        let success = false;\n        let lastError: string | undefined;\n        \n        // ============================================================\n        // TYMBER SSR EXTRACTION (v3.5.0 - No Browser Needed)\n        // Sites like Housing Works use Tymber/Blaze with SSR JSON\n        // ============================================================\n        if (isTymberSite(location.menuUrl)) {\n          console.log(`[Cron] \uD83D\uDE80 Using Tymber SSR extraction for ${location.name}`);\n          try {\n            const products = await fetchAndScrapeTymber(location.menuUrl);\n            const withQty = products.filter(p => p.quantity !== null).length;\n            \n            console.log(`[Cron] \u2713 ${location.name}: ${products.length} products (inventory: ${withQty}/${products.length} via Tymber SSR)`);\n            totalProducts += products.length;\n            totalInventoryChecked += products.length;\n            totalInventoryFound += withQty;\n            \n            results.push({\n              retailerSlug: location.retailerSlug,\n              items: products,\n              status: \"ok\",\n              attempts: 1,\n            });\n            \n            // Rate limit\n            await sleep(2000);\n            continue; // Skip to next location\n          } catch (tymberError) {\n            console.error(`[Cron] Tymber extraction failed for ${location.name}, falling back to browser:`, tymberError);\n            // Fall through to browser-based scraping\n          }\n        }\n        \n        // Try up to 3 times per location\n        for (let attempt = 1; attempt <= 3 && !success; attempt++) {\n          attempts = attempt;\n          console.log(`[Cron] Scraping ${location.name} (attempt ${attempt}/3)...`);\n          \n          const { products, error, inventoryStats } = await scrapeLocation(session, location);\n          \n          if (error) {\n            lastError = error;\n            console.error(`[Cron] \u2717 ${location.name} attempt ${attempt}: ${error}`);\n            \n            if (attempt < 3) {\n              const delay = 2000 * attempt;\n              await sleep(delay);\n            }\n          } else {\n            console.log(`[Cron] \u2713 ${location.name}: ${products.length} products (inventory: ${inventoryStats.found}/${inventoryStats.checked})`);\n            totalProducts += products.length;\n            totalInventoryChecked += inventoryStats.checked;\n            totalInventoryFound += inventoryStats.found;\n            results.push({\n              retailerSlug: location.retailerSlug,\n              items: products,\n              status: \"ok\",\n              attempts,\n            });\n            success = true;\n          }\n        }\n        \n        // If all retries failed, record error\n        if (!success && lastError) {\n          errors.push(`${location.name}: ${lastError}`);\n          results.push({\n            retailerSlug: location.retailerSlug,\n            items: [],\n            status: \"error\",\n            error: lastError,\n            attempts,\n          });\n        }\n        \n        // Rate limit: 2 second delay between locations\n        await sleep(2000);\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      console.error(`[Cron] Browser connection failed:`, errorMsg);\n      errors.push(`BrowserBase: ${errorMsg}`);\n    } finally {\n      if (session) {\n        try {\n          await session.close();\n        } catch (e) {\n          // Ignore close errors\n        }\n      }\n    }\n    \n    const duration = Math.round((Date.now() - startTime) / 1000);\n    \n    // Post results to Convex (with retry)\n    let ingestionResult: { totalEventsDetected?: number } | null = null;\n    try {\n      ingestionResult = await postToConvex(env.CONVEX_URL, batchId, results);\n      console.log(`[Cron] Posted ${results.length} results to Convex:`, ingestionResult);\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      console.error(`[Cron] Convex ingestion failed after retries:`, errorMsg);\n      errors.push(`Convex ingestion: ${errorMsg}`);\n    }\n    \n    // Trigger inventory event notifications (with retry)\n    try {\n      const notifyResult = await triggerDiscordNotifications(env.CONVEX_URL, env.DISCORD_WEBHOOK_URL);\n      if (notifyResult) {\n        console.log(`[Cron] Discord notifications:`, notifyResult);\n      }\n    } catch (e) {\n      console.error(`[Cron] Discord notification trigger failed:`, e);\n    }\n    \n    // Send summary to Discord (with retry)\n    const successCount = results.filter((r) => r.status === \"ok\").length;\n    const failCount = results.filter((r) => r.status === \"error\").length;\n    \n    const summaryEmbed: DiscordEmbed = {\n      title: \"\uD83C\uDF3F CannaSignal Scrape Complete\",\n      color: failCount === 0 ? 0x00ff00 : failCount < successCount ? 0xffaa00 : 0xff0000,\n      fields: [\n        { name: \"Batch ID\", value: batchId, inline: true },\n        { name: \"Duration\", value: `${duration}s`, inline: true },\n        { name: \"Locations\", value: `${successCount}/${activeLocations.length} (${disabledCount} disabled)`, inline: true },\n        { name: \"Products\", value: totalProducts.toString(), inline: true },\n        { name: \"Inventory\", value: `${totalInventoryFound}/${totalInventoryChecked} checked`, inline: true },\n        { name: \"Events\", value: ingestionResult?.totalEventsDetected?.toString() || \"N/A\", inline: true },\n      ],\n      footer: { text: \"v3.4.0 - parallel page visits\" },\n      timestamp: new Date().toISOString(),\n    };\n    \n    if (errors.length > 0) {\n      summaryEmbed.fields.push({\n        name: \"Error Details\",\n        value: errors.slice(0, 5).join(\"\\n\").slice(0, 1000),\n        inline: false,\n      });\n    }\n    \n    const summarySuccess = await sendDiscordSummary(env.DISCORD_WEBHOOK_URL, summaryEmbed);\n    if (!summarySuccess) {\n      console.error('[Cron] Failed to send Discord summary after all retries');\n    }\n    \n    console.log(`[Cron] Batch ${batchId} complete: ${successCount}/${activeLocations.length} active locations, ${totalProducts} products, ${totalInventoryFound} inventory counts, ${duration}s`);\n  },\n  \n  // HTTP handler for manual triggers and status\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n    \n    if (url.pathname === \"/health\") {\n      const activeLocations = getActiveLocations();\n      return Response.json({\n        status: \"ok\",\n        service: \"cannasignal-cron\",\n        version: \"3.4.0-parallel-pages\",\n        locations: {\n          total: EMBEDDED_LOCATIONS.length,\n          active: activeLocations.length,\n          disabled: EMBEDDED_LOCATIONS.length - activeLocations.length,\n        },\n        schedule: \"*/15 * * * *\",\n        convexUrl: env.CONVEX_URL,\n        features: [\n          \"cdp-native-client\",\n          \"per-location-retry\",\n          \"circuit-breaker\",\n          \"exponential-backoff\",\n          \"webhook-retry\",\n          \"disabled-location-support\",\n          \"product-detail-page-inventory\",\n          \"cart-hack-fallback\",\n          \"optimized-wait-times\",\n          \"parallel-page-pool\",\n          \"concurrent-product-visits\",\n        ],\n        config: {\n          maxDetailPageVisits: MAX_DETAIL_PAGE_VISITS_PER_LOCATION,\n          parallelPageCount: PARALLEL_PAGE_COUNT,\n          pageRenderWaitMs: PAGE_RENDER_WAIT_MS,\n          detailPageTimeoutMs: DETAIL_PAGE_TIMEOUT_MS,\n          cartHackEnabled: ENABLE_CART_HACK_FALLBACK,\n          maxCartHackAttempts: MAX_CART_HACK_ATTEMPTS,\n        },\n      });\n    }\n    \n    if (url.pathname === \"/trigger\" && request.method === \"POST\") {\n      const event = { cron: \"manual\", scheduledTime: Date.now() } as ScheduledEvent;\n      \n      // @ts-ignore - We're manually triggering\n      this.scheduled(event, env, {\n        waitUntil: (p: Promise<unknown>) => p,\n        passThroughOnException: () => {},\n      });\n      \n      return Response.json({\n        triggered: true,\n        timestamp: new Date().toISOString(),\n        message: \"Scrape triggered, check Discord for results\",\n      });\n    }\n    \n    if (url.pathname === \"/locations\") {\n      const activeLocations = getActiveLocations();\n      return Response.json({\n        total: EMBEDDED_LOCATIONS.length,\n        active: activeLocations.length,\n        disabled: EMBEDDED_LOCATIONS.length - activeLocations.length,\n        locations: EMBEDDED_LOCATIONS.map((l) => ({\n          name: l.name,\n          retailer: l.retailerName,\n          url: l.menuUrl,\n          region: l.region,\n          status: l.disabled ? \"disabled\" : \"active\",\n          disabledReason: l.disabledReason,\n        })),\n      });\n    }\n    \n    return Response.json({\n      service: \"cannasignal-cron\",\n      version: \"3.4.0-parallel-pages\",\n      endpoints: [\n        \"GET /health - Service health with location stats\",\n        \"POST /trigger - Manual scrape trigger\",\n        \"GET /locations - All locations with status\",\n      ],\n    });\n  },\n};\n"],
  "mappings": "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",
  "names": ["reject", "products"]
}
